---
title: "Functions and Closures"
template: slides
---

## Background

-   The little programming language of [%x interp %] isn't extensible

-   So add a way to define and call functions

-   And then look at design tactics this opens up

---

## Definition and Call

[% inc file="../example_def.py" keep="def" %]

-   Name

-   (Possibly empty) list of parameter names

-   Body (usually a `seq`)

--

[% inc file="../example_def.py" keep="call" %]

-   Values can be expressions (not in a sub-list)

---

## Storing a Function

-   Like any other value

[% inc file="../example_def.py" keep="store" %]

--

-   Could just use this for defining

[% inc file="../example_def.py" keep="alt" %]

---

## Implementing Call

1.  Evaluate all of these expressions.

2.  Look up the function.

3.  Create a new environment whose keys are the parameters' names
    and whose values are the expressions' values.

4.  Call `do` to run the function's action and captures the result.

5.  Discard environment created two steps previously.

6.  Return the function's result.

---

## The Environment

-   A variable `x` in a function shouldn't clobber
    a variable with the same name in its caller

-   Use a list of dictionaries to implement a
    [%g call_stack "call stack" %]

-   Each dictionary called a [%g stack_frame "stack frame" %]

-   Look down the stack to find the name

-   If not found, add to the current (top-most) frame

---

## Implementing Definition

[% inc file="../func.py" keep="def" %]

---

## Implementing Call

[% inc file="../func.py" keep="call" %]

---

## A Test

[% inc pat="../func.*" fill="tll out" %]

---

## Dynamic Scoping

-   Searching active stack for a variable is called [%g dynamic_scoping "dynamic scoping" %]

[% inc pat="../dynamic.*" fill="tll out" %]

-   Have to trace execution to figure out what a variable might refer to

---

## Lexical Scoping

-   Almost all languages used [%g lexical_scoping "lexical scoping" %]

-   Decide what a name refers to based on the structure of the program

-   More efficient for the computer: doesn't have to search each time

-   More efficient for the person: limits scope of reasoning

-   And enables a very powerful programming technique

---

## Closures

-   Define a function inside a function and return the inner function

[% inc pat="../closure.*" fill="py out" %]

-   The inner function [%g variable_capture "captures" %] the variables in the enclosing function

FIXME: diagram

---

## A More Useful Example

[% inc pat="../adder.*" fill="py out" %]

-   A way to manage private data

---

## Objects

[% inc pat="../oop.*" fill="py out" %]

---

## Wrapping Functions

[% inc pat="../wrap_infinite.*" fill="py out" %]

-   Well, that didn't work

---

## Capture the Original

[% inc pat="../wrap_capture.*" fill="py out" %]

---

## Parameters

[% inc pat="../wrap_param.*" fill="py out" %]

---

## Decorators

[% inc pat="../decorator_simple.*" fill="py out" %]

---

## Design Flaw

-   A decorator takes exactly one argument (the function to decorate)

-   So how do we pass other parameters to the decorator itself?

-   Simple answer would have been to model decorator behavior
    on method definition and call

    -   First argument `self` is handled specially,
        so why not a special first argument `func` for decorators?

-   Instead, use a closure to capture the parameters to a decorator
    and return a function that wraps the user's function

---

## Decorator Parameters

[% inc pat="../decorator_param.*" fill="py out" %]
