---
title: "Functions and Closures"
template: slides
---

## Background

-   The little programming language of [%x interp %] isn't extensible

-   So add a way to define and call functions

-   And then look at design tactics this opens up

---

## Defining a Function

-   Name

-   (Possibly empty) list of parameter names

-   Body (usually a `seq`)

[% inc file="../example_def.py" keep="def" %]

---

## Storing a Function

-   Like any other value

[% inc file="../example_def.py" keep="store" %]

--

-   Could just use this for defining

[% inc file="../example_def.py" keep="alt" %]

---

## Calling a Function

[% inc file="../example_def.py" keep="call" %]

-   Values can be expressions (not in a sub-list)

---

## Implementation of Function Call

1.  Evaluate all of these expressions.

2.  Look up the function.

3.  Create a new environment whose keys are the parameters' names
    and whose values are the expressions' values.

4.  Call `do` to run the function's action and captures the result.

5.  Discard environment created two steps previously.

6.  Return the function's result.

---

## The Environment

-   A variable `x` in a function shouldn't clobber
    a variable with the same name in its caller

-   Use a list of dictionaries to implement a
    [%g call_stack "call stack" %]

-   Each dictionary called a [%g stack_frame "stack frame" %]

-   Look down the stack to find the name

-   If not found, add to the current (top-most) frame

---

## Implementing Definition

[% inc file="func.py" keep="def" %]

---

## Implementing Call

[% inc file="func.py" keep="call" %]

---

## A Test

[% inc pat="func.*" fill="tll out" %]

---

## Dynamic Scoping

-   Searching active stack frames for a variable is called [%g dynamic_scoping "dynamic scoping" %]

[% inc pat="../dynamic.*" fill="tll out" %]

-   Have to trace execution to figure out what a variable might refer to

---

## Lexical Scoping

-   Almost all languages used [%g lexical_scoping "lexical scoping" %]

-   Decide what a name refers to based on the structure of the program

-   More efficient for the computer: doesn't have to search each time

-   More efficient for the person: limits scope of reasoning

---

## Closures

-   Define a function inside a function and return the inner function

[% inc pat="../closure.*" fill="py out" %]

FIXME: diagram

---

## A More Useful Example

[% inc pat="../adder.*" fill="py out" %]

-   A way to manage private data

---

## Object-Oriented Programming

[% inc pat="../oop.*" fill="py out" %]
