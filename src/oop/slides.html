---
template: slides
---

## The Problem(s)

-   What is a natural way to represent real-world "things" in code?

-   How can we organize code to make it easier to understand, test, and extend?

-   Are these the same thing?

---

## The Big Idea

<p class="shout">A program is just another data structure.</p>

[% figure
   slug="oop-func-obj"
   img="func_obj.svg"
   alt="Bytes as characters, pixels, or instructions"
   caption="Bytes can be interpreted as characters, pixels, or instructions."
%]

---

## Functions are Objects

-   `def` defines a variable whose value is the function's instructions

[% inc file="func_obj.py" keep="def" %]

-   We can assign that value to another variable

[% inc file="func_obj.py" keep="alias" %]
[% inc file="func_obj.out" %]

---

## Representing Shapes

-   Start with the [%g design_by_contract contract %] for shapes

[% inc file="shapes_original.py" keep="shape" %]

---

## Provide Implementations

[% inc file="shapes_original.py" keep="concrete" %]

---

## Polymorphism

[% inc file="shapes_original.py" keep="poly" %]

--

-   OK, but how does it work?

---

## Let's Make a Square

[% inc file="shapes_dict.py" keep="square" %]

--

-   An object is just a (specialized) dictionary

-   A method is just a function that takes the object as its first parameter

---

## Let's Make a Square

[% figure
   slug="oop-shapes-dict"
   img="shapes_dict.svg"
   alt="Storing shapes as dictionaries"
   caption="Using dictionaries to emulate objects."
%]

---

## Calling Methods

[% inc file="shapes_dict.py" keep="call" %]

-   Look up the function in the object

-   Call it with the object as its first argument

-   `obj.meth(arg)` is `obj["meth"](obj, arg)`

---

## A Better Square

[% inc file="shapes_class.py" keep="square" %]

---

## Calling Methods

[% inc file="shapes_class.py" keep="call" %]

-   Look in the class for the method

-   Call it with the object as the first parameter

-   And we can now reliably identify objects' classes

---

## Calling Methods

[% figure
   slug="oop-shapes-class"
   img="shapes_class.svg"
   alt="Separating properties from methods"
   caption="Using dictionaries to emulate classes."
%]

---

class: aside

## Variable Arguments

[% inc pat="varargs.*" fill="py out" %]

---

class: aside

## Spreading

[% inc pat="spread.*" fill="py out" %]

---

## Inheritance

-   Add a method to `Shape` that uses methods defined in derived classes

[% inc file="inherit_original.py" keep="shape" %]

---

## Inheritance

[% figure
   slug="oop-inherit-class"
   img="inherit_class.svg"
   alt="Implementing inheritance"
   caption="Using dictionary search to implement inheritance."
%]

---

## Yes, This Works

[% inc file="inherit_original.py" keep="use" %]
[% inc file="inherit_original.out" %]

---

## Implementing Inheritance

[% inc file="inherit_class.py" keep="shape" %]

---

## Searching for Methods

[% inc file="inherit_class.py" keep="search" %]

---

## Yes, This Works Too

[% inc file="inherit_class.py" keep="use" %]
[% inc file="inherit_class.out" %]

---

## Constructors

[% inc file="inherit_constructor.py" keep="shape" %]

---

## Parentage

[% inc file="inherit_constructor.py" keep="square" %]

---

## Use

[% inc file="inherit_constructor.py" keep="call" %]
[% inc file="inherit_constructor.out" %]
