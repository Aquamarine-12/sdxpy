---
template: slides
---

## The Problem

-   Packages and their dependencies change over time

-   If A and B require different versions of C
    it might not be possible to use A and B together

-   Need a systematic way to find globally-consistent sets of packages

---

## Identifying Versions

-   [%g semantic_versioning "Semantic versioning" %] uses three integers `X.Y.Z`

    -   `X` is the major version (breaking changes)

    -   `Y` is the minor version (new features)

    -   `Z` is the [%g patch "patch" %] (bug fixes)

-   Notation

    -   `>=1.2.3` means "any version from 1.2.3 onward"

    -   `<4` means "any version before 4.anything"

    -   `1.0-3.1` means "any version in the specified range"

---

## A Simplified Version

[% inc file="triple.json" %]

---

## Multiple Dimensions

-   Imagine a multi-dimensional grid with one axis per package

-   Possible combinations are points in this grid

[% figure
   slide=True
   slug="pack-allowable"
   img="allowable.svg"
   alt="Allowable versions"
   caption="Finding allowable combinations of package versions."
%]

-   But how do we find the legal ones?

---

## Estimate Work

-   Our example has 3×3×2=18 combinations

-   Adding one more package with two versions doubles
    the [%g search_space "search space" %]

-   A [%g combinatorial_explosion "combinatorial explosion" %]

-   Brute force solutions are impractical even for small problems

-   But worth implementing as a starting point and for testing

---

## Brute Force

-   Generate all possible combinations of package versions

-   Then eliminate ones that aren't compatible with the manifest

[% inc file="exhaustive.py" keep="main" %]

---

## Generating Possibilities

-   Create a list of the available versions of each package

-   Generate their [%g cross_product "cross product" %]

[% inc file="exhaustive.py" keep="possible" %]

[% figure
   slide=True
   slug="pack-product"
   img="product.svg"
   alt="Generating a cross-product"
   caption="Generating all possible combinations of items."
%]

---

## Checking Validity

-   Compare every entry X against every other entry Y

-   If they are the same package, keep looking

-   If package X's requirements say nothing about package Y,
    keep searching

-   If X *does* depend on Y
    but this particular version of X doesn't list this particular version of Y
    as a dependency,
    rule out this combination

-   If combination is still a candidate, add to list

---

## Checking Validity

[% inc file="exhaustive.py" keep="compatible" %]

-   Finds 3 valid combinations among our 18 possibilities

[% inc file="exhaustive.out" %]

---

## Manual Generation

-   Create our own cross-product function
    in preparation for doing something more efficient

[% inc file="manual.py" keep="start" %]

-   Create a list of lists of available versions

-   Create an empty accumulator

-   Do some magic

---

## Manual Generation

-   Each call to `_make_possible` handles one package's worth of work

-   Loop over available versions of current package

-   Add that package to the combination in progress

-   If more packages, recurse

-   Otherwise, append to accumulator

[% inc file="manual.py" keep="make" %]

---

##

[% figure
   slide=True
   slug="pack-recursive"
   img="recursive.svg"
   alt="Generating a cross-product recursively"
   caption="Generating all possible combinations of items recursively."
%]

-   Use recursion instead of nested loops
    because we don't know how many loops to write

-   The [%g recursive_enumeration_pattern "Recursive Enumeration" %] design pattern

---

## Incremental Search

-   Generate-and-discard is inefficient

-   Stop immediately if a partial combination of packages is illegal

[% inc file="incremental.py" keep="main" %]

--

-   `reverse` to allow experimentation

---

## Finding Possibilities

[% inc file="incremental.py" keep="find" %]

---

## Finding Possibilities

1.  The manifest that tells us what's compatible with what.

2.  The names of the packages we've haven't considered yet.

3.  An accumulator to hold all the valid combinations we've found so far.

4.  The partially-completed combination we're going to extend next.

5.  A count of the number of combinations we've considered so far,
    which we will use as a measure of efficiency.

---

## Savings

-   We only create 11 candidates instead of 18

[% inc pat="incremental.*" fill="sh out" %]

-   Reversing the order cuts it to 9

[% inc pat="incremental_reverse.*" fill="sh out" %]

---

## Using a Theorem Prover

-   An [%g theorem_prover "automated theorem prover" %] can do much better 

    -   But the algorithms quickly become very complex

-   Prove that a set of logical propositions (e.g., dependencies) are satisfiable

-   We will use the [Z3 theorem prover][z3]

    -   Whose documentation is unfortunately a barrier to entry

---

## Using Z3

[% inc file="z3_equal.py" keep="setup" %]

-   `A`, `B`, and `C` don't have values

-   Instead, each represents the set of possible Boolean values

---

## Using Z3

-   Specify constraints such as `A == B`

[% inc file="z3_equal.py" keep="solve" %]

-   Then ask Z3 to find a [%g model "model" %] that satisfies those constraints

[% inc file="z3_equal.out" %]

---

## Unsatisfiable

-   Require `A` to equal `B` and `B` to equal `C`
    but `A` and `C` to be unequal

[% inc file="z3_unequal.py" keep="solve" %]
[% inc file="z3_unequal.out" %]

---

## Packaging

-   Represent our package versions

[% inc file="z3_triple.py" keep="setup" %]

---

## Packaging

-   We want one version of `A`

[% inc file="z3_triple.py" keep="top" %]

-   But the versions of `A` are mutually exclusive

[% inc file="z3_triple.py" keep="exclusive" %]

-   Do the same for `B` and `C`

---

## Dependencies

-   Add inter-package dependencies and solve

[% inc file="z3_triple.py" keep="depends" %]
[% inc file="z3_triple.out" %]

---

## Summary

[% figure
   slide=True
   slug="packman-concept-map"
   img="concept_map.svg"
   alt="Concept map for package manager."
   caption="Concepts for package manager."
%]

---

class: exercise

## Comparing Semantic Versions

Write a function that takes an array of semantic version specifiers
and sorts them in ascending order.
Remember that `2.1` is greater than `1.99`.

---

class: exercise

## Parsing Semantic Versions

Write a parser for a subset of the [semantic versioning specification][semver_spec].

---

class: exercise

## Using Scoring Functions

Many different combinations of package versions can be mutually compatible.
One way to decide which actual combination to install
is to create a [%g scoring_function "scoring function" %]
that measures how good or bad a particular combination is.
For example,
a function could measure the "distance" between two versions as:

-   100 times the difference in major version numbers;

-   10 times the difference in minor version numbers
    if the major numbers agree;
    and

-   the difference in the patch numbers
    if both major and minor numbers agree.

1.  Implement this function
    and use it to measure the total distance between
    the set of packages found by the solver
    and the set containing the most recent version of each package.

2.  Explain why this doesn't actually solve the original problem.

---

class: exercise

## Regular Releases

Some packages release new versions on a regular cycle,
e.g.,
Version 2021.1 is released on March 1 of 2021,
Version 2021.2 is released on September 1 of that year,
version 2022.1 is released on March 1 of the following year,
and so on.

1.  How does this make package management easier?

2.  How does it make it more difficult?

---

class: exercise

## Searching Least first

Rewrite the constraint solver so that it searches packages
by looking at those with the fewest available versions first.
Does this reduce the amount of work done for the small examples in this chapter?
Does it reduce the amount of work done for larger examples?

---

class: exercise

## Using Exclusions

1.  Modify the constraint solver so that
    it uses a list of package exclusions instead of a list of package requirements,
    i.e.,
    its input tells it that version 1.2 of package Red
    can *not* work with versions 3.1 and 3.2 of package Green
    (which implies that Red 1.2 can work with any other versions of Green).

2.  Explain why package managers aren't built this way.

---

class: exercise

## Generating Constraints

Write a function that reads a JSON manifest describing package compatibilities
and generates the constraints needed by the Z3 theorem prover.

---

class: exercise

## Buildability

1.  Convert the build dependencies from one of the examples in [%x build %]
    to a set of constraints for Z3
    and use the solution to find a legal build order.

2.  Modify the constraints to introduce
    a [%g circular_dependency "circular dependency" %]
    and check that the solver correctly determines
    that there is no legal build order.
