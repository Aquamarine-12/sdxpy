---
template: slides
---

## The Problem

-   Not all software needs formal testing
    -   Check one-off data analysis script incrementally
-   But 98% of the code in [SQLite][sqlite] is there to test the other 2%
    -   For which I am grateful
-   Good tools make tests easier to write
    -   So that programmers have fewer excuses not to write them
-   This lesson build a unit testing framework like [pytest][pytest]
    -   Most frameworks in most other languages share its design

---

## The Big Idea

<p class="shout">A program is just another data structure.</p>

[% figure
   slug="test-func-obj"
   img="func_obj.svg"
   alt="Bytes as characters, pixels, or instructions"
   caption="Bytes can be interpreted as characters, pixels, or instructions."
%]

---

## Functions are Objects

-   `def` defines a variable whose value is the function's instructions

[% inc file="func_obj.py" keep="def" %]

-   We can assign that value to another variable

[% inc file="func_obj.py" keep="alias" %]
[% inc file="func_obj.out" %]

---

class: aside

## Checking

-   Use `type` to see if something is a function

[% inc pat="type_int.*" fill="py out" %]

[% inc pat="type_func.*" fill="py out" %]

---

class: aside

## Checking

-   But built-in functions have a different type

[% inc pat="type_len.*" fill="py out" %]

-   So use `callable` to check if something can be called

[% inc pat="callable.*" fill="py out" %]

---

## Functions in Lists

-   We can put functions in lists

[% inc pat="func_list.*" fill="py out" %]

---

## Signatures

-   We have to know how to call the functions
    -   They must have the same [%g signature "signature" %]

[% inc pat="signature.*" fill="py out" %]

---

## Testing Terminology

-   Apply the function we want to test to a [%g fixture "fixture" %]
-   Compare the [%g actual_result "actual result" %]
    to the [%g expected_result "expected result" %]
-   Possible outcomes are:
    -   [%g pass_test "pass" %]: the target function worked
    -   [%g fail_test "fail" %]: the target function didn't do what we expected
    -   [%g error_test "error" %]: something went wrong with the test itself
-   Typically use `assert` to check results
    -   If condition is `True`, does nothing
    -   Otherwise, raises an `AssertionError`
-   Failed assertions usually cause the program to halt
    -   But we can catch the exception ourselves if we want

---

## A Function and Some Tests

[% inc file="manual.py" keep="sign" %]
[% inc file="manual.py" keep="tests" %]

---

## What We Want

[% inc file="manual.py" keep="save" %]
[% inc file="manual.out" %]

---

## How We Do It

[% inc file="manual.py" keep="run" %]

-   Easy to create new tests
-   But we have to remember to add each one to `TESTS`

---

## How Python Stores Variables

-   Python stores variables in (something very much like) a dictionary

[% inc pat="globals.*" fill="py out" %]

---

## Further Proof

[% inc pat="globals_plus.*" fill="py out" %]

--

-   The function `locals` gives local variables

---

## Introspection

-   We know how to loop over a dictionary's keys

[% inc file="find_test_funcs.py" keep="main" %]
[% inc file="find_test_funcs.out" %]

--

-   When we print a function, Python shows its name and address

---

## A Better Test Runner

[% inc file="runner.py" keep="run" %]

--

-   Really should check that tests are callable

---

## Who's Your Audience?

[% figure
   slug="test-comprehension"
   img="comprehension.svg"
   alt="Abstract vs. comprehension"
   caption="Abstraction vs. comprehension for novices and experts."
%]

-   Experts understand lower and higher abstraction levels than novices

-   Preferred level shifts with experience

-   Code that is optimal for one reader may not be optimal for another

---

class: summary

## Summary	       

[% figure
   slug="test-concept-map"
   img="concept_map.svg"
   alt="Concept map of unit testing framework"
   caption="Concept map"
%]
